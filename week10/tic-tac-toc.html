<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tic-tac-toc</title>
    <style>
      main {
        position: relative;
        height: 80vh;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }
      .checkerboard {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-content: space-between;
        width: 30vw;
        height: 30vw;
      }
      .cell {
        width: 9.8vw;
        height: 9.8vw;
        background-color: #3d5a80;
        line-height: 33%;
        font-size: 4.5vw;
        line-height: 10.6vw;
        text-align: center;
        color: #ee6c4d;
        cursor: pointer;
      }
      .hint {
        color: #293241;
        margin-bottom: 20px;
        font-size: 20px;
      }
      .info {
        position: absolute;
        top: 0;
        text-align: center;
        font-size: 30px;
      }
      .btn{
        margin-top: 20px;
      }
      button{
        font-size: 20px;
      }
      .best-choice{
        margin-left: 20px;
      }
    </style>
  </head>
  <body>
    <main>
      <div class="hint">&nbsp;</div>
      <div class="checkerboard"></div>
      <div class="info"><span id="piece">â­•ï¸</span> æ–¹å›åˆ</div>
      <div class="btn"><button class="restart">é‡æ–°å¼€å§‹</button><button class="best-choice">æœ€å¥½çš„é€‰æ‹©</button><div>
    </main>

    <script>
      const X = 'âŒ';
      const O = 'â­•ï¸';
      let pattern = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
      ];
      let piece = O; // æ£‹å­çš„ç§ç±»
      let isEnd = false;

      let board = document.querySelector('.checkerboard');
      let hintEle = document.querySelector('.hint');
      let pieceName = document.querySelector('#piece');
      let restartBtn = document.querySelector('.restart');
      let bestChoiceBtn = document.querySelector('.best-choice');

      restartBtn.addEventListener('click',() => {
        initialize();
        render();
      });

      bestChoiceBtn.addEventListener('click',() => {
        const {point, result} = bestChoice(pattern, piece);
        if(point){
          putPiece(point[1], point[0]);
        }
      })

      function initialize(){
        pattern = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
       ];
        piece = O;
        hint('&nbsp;')
        pieceName.innerHTML = O;
        isEnd = false;
      }

      function render() {
        board.innerHTML = '';
        pattern.forEach((row, y) => {
          row.forEach((str, x) => {
            let cell = document.createElement('div');
            cell.classList.add('cell');
            cell.addEventListener('click', () => {
              putPiece(y, x);
            });
            cell.innerHTML = str ? str : '';
            board.appendChild(cell);
          });
        });
      }

      function putPiece(y, x) {
        if(isEnd){
          alert('æ¸¸æˆç»“æŸï¼Œè¯·é‡æ–°å¼€å§‹');
          return;
        }
        let hasPiece = !!pattern[y][x];
        let currentPiece = piece;
        if (hasPiece) {
          // alert('å·²æœ‰æ£‹å­');
          return;
        } else {
          pattern[y][x] = piece;
          piece = piece === X ? O : X;
          pieceName.innerHTML = piece;
        }
        // æ¸²æŸ“ UI
        render('&nbsp;');

        // åˆ¤æ–­æ˜¯å¦æŸä¸€æ–¹è¦è·èƒœ
        if (willWin(pattern, currentPiece)) {
          hint(`æé†’ï¼š${currentPiece} æ–¹è¦è·èƒœäº†ğŸ˜¨`);
        }else{
          hint(`&nbsp;`);
        }

        if (judge(pattern, currentPiece)) {
          hint(`${currentPiece} æ–¹èƒœåˆ©âœŒï¸`);
          isEnd = true;
        }
      }

      // åˆ¤æ–­æ¸¸æˆæ˜¯å¦æœ‰èƒœåˆ©çš„ä¸€æ–¹
      function judge(pattern, piece) {
        for (let i = 0; i < 3; i++) {
          // ä¸‰è¡Œç›¸åŒ
          {
            // é»˜è®¤è®¤ä¸ºæ˜¯ä¼šèµ¢
            let win = true;
            for (let j = 0; j < 3; j++) {
              if (pattern[i][j] !== piece) {
                win = false;
                break;
              }
            }
            if (win) {
              return true;
            }
          }

          // ä¸‰åˆ—ç›¸åŒ
          {
            let win = true;
            for (let j = 0; j < 3; j++) {
              if (pattern[j][i] !== piece) {
                win = false;
                break;
              }
            }
            if (win) {
              return true;
            }
          }

          // å·¦ä¸Šåˆ°å³ä¸‹çš„æ–œå‘
          {
            let win = true;
            for (let j = 0; j < 3; j++) {
              if (pattern[j][j] !== piece) {
                win = false;
                break;
              }
            }
            if (win) {
              return true;
            }
          }

          // å·¦ä¸‹åˆ°å³ä¸Šçš„
          {
            let win = true;
            for (let j = 0; j < 3; j++) {
              if (pattern[2 - j][j] !== piece) {
                win = false;
                break;
              }
            }
            if (win) {
              return true;
            }
          }
        }
        return false;
      }

      function clone(obj) {
        // å¾ˆæ¶ˆè€—æ€§èƒ½
        return JSON.parse(JSON.stringify(obj));
      }

      function willWin(pattern, piece) {
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (pattern[i][j] !== 0) {
              continue;
            }
            let temp = clone(pattern);
            temp[i][j] = piece;
            if (judge(temp, piece)) {
              return [j, i]; // j æ˜¯ Y è½´ï¼Œi æ˜¯ X è½´
            }
          }
        }
        return null;
      }

      // æ£‹è°±
      let manual = new Map();
      manual.set([
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
       ].toString() + O, {
         point: [1,1],
         result: 0
       })
       manual.set([
        [0, 0, 0],
        [0, O, 0],
        [0, 0, 0],
       ].toString() + X, {
         point: [0,0],
         result: 0
       })

      // å¯¹äºè¦ä¸‹æ£‹å­é‚£ä¸€æ–¹çš„æœ€å¥½é¢„åˆ¤ï¼Œä¼˜åŒ–ï¼šå¯ä»¥ç»™ pattern æ·»åŠ ä¸€ä¸ª hashï¼Œå¦‚æœå·²ç»æœç´¢è¿‡è¿™ä¸ªæ¨¡å¼ï¼Œå°±ä¸ç”¨æœ
      function bestChoice(pattern, piece) {
        let key = pattern.toString() + piece; // ä½¿ç”¨å½“å‰æ£‹å±€çš„æ¨¡å‹å’Œæ£‹æ–¹å½¢æˆä¸€ä¸ªå­—ç¬¦ä¸² hash key
        if(manual.get(key)){
          return manual.get(key);
        }
        let point = willWin(pattern, piece);
        // å¦‚æœæœ‰ point è¯´æ˜è¦èƒœåˆ©äº†ï¼Œè¿™é‡Œä¹Ÿæ˜¯é€’å½’çš„é€€å‡ºæ¡ä»¶ä¹‹ä¸€
        if (point) {
          return {
            point,
            result: 1, // -1 è¾“ 0 å¹³ 1 èµ¢
          };
        }

        // é»˜è®¤è®¤ä¸ºè‡ªå·±å¤„äºæœ€åçš„æƒ…å†µ
        let result = -1;

        // æ£€æŸ¥æ£‹ç›˜ä¸­çš„æ¯ä¸€ä¸ªå¯èƒ½ä¼šèµ°çš„ç‚¹ï¼Œå¹¶ä¸”è·å¾—å¯¹æ–¹çš„æœ€å¥½é€‰æ‹©
        outer: for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (pattern[i][j] !== 0) {
              continue;
            }
            let temp = clone(pattern);
            // æˆ‘æ–¹åœ¨æŸä¸ªç©ºä½ä¸‹ä¸€ä¸ªæ£‹å­
            temp[i][j] = piece;
            // è·å–å¯¹æ‰‹çš„æœ€å¥½é€‰æ‹©
            let opposite = bestChoice(temp, piece === O ? X : O); 
            // å¯¹æ‰‹æœ€å·®çš„ç»“æœå°±æ˜¯æˆ‘æ–¹æœ€æƒ³è¦çš„ç»“æœï¼Œé‚£ä¹ˆå¯¹ opposite.result å–ååˆ™æ˜¯æˆ‘æ–¹æƒ³è¦çš„æƒ…å†µ
            // å¦‚æœè¿™ä¸ªæƒ…å†µæ¯”æˆ‘æ–¹ç°åœ¨çš„æƒ…å†µå¥½ï¼Œé‚£ä¹ˆæˆ‘å°±ç”¨è¿™ä¸ªç»“æœ
            if (-opposite.result >= result) {
              point = [j, i];
              result = -opposite.result;
            }
            // æ²¡æœ‰è¿™ä¸€æ¡ç­‰äºå…¨ç›˜æœç´¢ï¼Œç°åœ¨åšæˆäº† win lose å‡æï¼Œå‡å°‘è¿ç®—é‡ 
            if(result === 1){
              break outer;
            }
          }
        }

        return {
          point,
          result: point ? result : 0,
        };
      }
 
      function hint(str) {
        hintEle.innerHTML = str;
      }

      render();
    </script>
  </body>
</html>
